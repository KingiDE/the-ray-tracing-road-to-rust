## The vec3 Class

Almost all graphics programs have some class(es) for storing geometric vectors and colors. In many
systems these vectors are 4D (3D plus a homogeneous coordinate for geometry, and RGB plus an alpha
transparency channel for colors). For our purposes, three coordinates suffices. We’ll use the same
class `vec3` for colors, locations, directions, offsets, whatever. Some people don’t like this
because it doesn’t prevent you from doing something silly, like adding a color to a location. They
have a good point, but we’re going to always take the “less code” route when not obviously wrong.
In spite of this, we do declare two aliases for `vec3`: `point3` and `color`. Since these two types
are just aliases for `vec3`, you won't get warnings if you pass a `color` to a function expecting a
`point3`, for example. We use them only to clarify intent and use.

## Variables and Methods

Here’s the top part of my `vec3` class:

```cpp filename="vec3.h (vec3 class)"
    #ifndef VEC3_H
    #define VEC3_H

    #include <cmath>
    #include <iostream>

    using std::sqrt;

    class vec3 {
        public:
            vec3() : e{0,0,0} {}
            vec3(double e0, double e1, double e2) : e{e0, e1, e2} {}

            double x() const { return e[0]; }
            double y() const { return e[1]; }
            double z() const { return e[2]; }

            vec3 operator-() const { return vec3(-e[0], -e[1], -e[2]); }
            double operator[](int i) const { return e[i]; }
            double& operator[](int i) { return e[i]; }

            vec3& operator+=(const vec3 &v) {
                e[0] += v.e[0];
                e[1] += v.e[1];
                e[2] += v.e[2];
                return *this;
            }

            vec3& operator*=(const double t) {
                e[0] *= t;
                e[1] *= t;
                e[2] *= t;
                return *this;
            }

            vec3& operator/=(const double t) {
                return *this *= 1/t;
            }

            double length() const {
                return sqrt(length_squared());
            }

            double length_squared() const {
                return e[0]*e[0] + e[1]*e[1] + e[2]*e[2];
            }

        public:
            double e[3];
    };

    // Type aliases for vec3
    using point3 = vec3;   // 3D point
    using color = vec3;    // RGB color

    #endif
```

We use `double` here, but some ray tracers use `float`. Either one is fine -- follow your own
tastes.

## vec3 Utility Functions

The second part of the header file contains vector utility functions:

```cpp filename="vec3.h (vec3 utility functions)"
    // vec3 Utility Functions

    inline std::ostream& operator<<(std::ostream &out, const vec3 &v) {
        return out << v.e[0] << ' ' << v.e[1] << ' ' << v.e[2];
    }

    inline vec3 operator+(const vec3 &u, const vec3 &v) {
        return vec3(u.e[0] + v.e[0], u.e[1] + v.e[1], u.e[2] + v.e[2]);
    }

    inline vec3 operator-(const vec3 &u, const vec3 &v) {
        return vec3(u.e[0] - v.e[0], u.e[1] - v.e[1], u.e[2] - v.e[2]);
    }

    inline vec3 operator*(const vec3 &u, const vec3 &v) {
        return vec3(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2]);
    }

    inline vec3 operator*(double t, const vec3 &v) {
        return vec3(t*v.e[0], t*v.e[1], t*v.e[2]);
    }

    inline vec3 operator*(const vec3 &v, double t) {
        return t * v;
    }

    inline vec3 operator/(vec3 v, double t) {
        return (1/t) * v;
    }

    inline double dot(const vec3 &u, const vec3 &v) {
        return u.e[0] * v.e[0]
             + u.e[1] * v.e[1]
             + u.e[2] * v.e[2];
    }

    inline vec3 cross(const vec3 &u, const vec3 &v) {
        return vec3(u.e[1] * v.e[2] - u.e[2] * v.e[1],
                    u.e[2] * v.e[0] - u.e[0] * v.e[2],
                    u.e[0] * v.e[1] - u.e[1] * v.e[0]);
    }

    inline vec3 unit_vector(vec3 v) {
        return v / v.length();
    }
```

## Color Utility Functions

Using our new `vec3` class, we'll create a utility function to write a single pixel's color out to
the standard output stream.

```cpp filename="color.h (color utility functions)"
   #ifndef COLOR_H
   #define COLOR_H

   #include "vec3.h"

   #include <iostream>

   void write_color(std::ostream &out, color pixel_color) {
       // Write the translated [0,255] value of each color component.
       out << static_cast<int>(255.999 * pixel_color.x()) << ' '
           << static_cast<int>(255.999 * pixel_color.y()) << ' '
           << static_cast<int>(255.999 * pixel_color.z()) << '\n';
   }

   #endif
```

Now we can change our main to use this:

```cpp filename="main.cc (Final code for the first PPM image)"
#include "color.h"
#include "vec3.h"

#include <iostream>

int main() {

    // Image

    const int image_width = 256;
    const int image_height = 256;

    // Render

    std::cout << "P3\n" << image_width << ' ' << image_height << "\n255\n";

    for (int j = image_height-1; j >= 0; --j) {
        std::cerr << "\rScanlines remaining: " << j << ' ' << std::flush;
        for (int i = 0; i < image_width; ++i) {
            color pixel_color(double(i)/(image_width-1), double(j)/(image_height-1), 0.25);
            write_color(std::cout, pixel_color);
        }
    }

    std::cerr << "\nDone.\n";
}
```
