## Shading with Surface Normals

First, let's get ourselves a surface normal so we can shade. This is a vector that is perpendicular
to the surface at the point of intersection. There are two design decisions to make for normals.
The first is whether these normals are unit length. That is convenient for shading so I will say
yes, but I won't enforce that in the code. This could allow subtle bugs, so be aware this is
personal preference as are most design decisions like that. For a sphere, the outward normal is in
the direction of the hit point minus the center:

![Figure \[sphere-normal\]: Sphere surface-normal geometry](../images/fig-1.05-sphere-normal.jpg)

On the earth, this implies that the vector from the earth's center to you points straight up. Let's
throw that into the code now, and shade it. We don't have any lights or anything yet, so let's just
visualize the normals with a color map. A common trick used for visualizing normals (because it's
easy and somewhat intuitive to assume $\mathbf{n}$ is a unit length vector -- so each
component is between -1 and 1) is to map each component to the interval from 0 to 1, and then map
x/y/z to r/g/b. For the normal, we need the hit point, not just whether we hit or not. We only have
one sphere in the scene, and it's directly in front of the camera, so we won't worry about negative
values of $t$ yet. We'll just assume the closest hit point (smallest $t$). These changes in the code
let us compute and visualize $\mathbf{n}$:

<Tabs>
  <Tab label="Rust">
    ```rust filename="main.rs | Rendering surface normals on a sphere" {11,17-21,25-28} genImage
    mod color;
    mod ray;
    mod vec3;

    use std::io;

    use color::Color;
    use ray::Ray;
    use vec3::{Point3, Vec3};

    fn hit_sphere(center: Point3, radius: f64, r: &Ray) -> f64 {
        let oc = r.origin() - center;
        let a = vec3::dot(r.direction(), r.direction());
        let b = 2.0 * vec3::dot(oc, r.direction());
        let c = vec3::dot(oc, oc) - radius * radius;
        let discriminant = b * b - 4.0 * a * c;
        if discriminant < 0.0 {
            -1.0
        } else {
            (-b - f64::sqrt(discriminant)) / (2.0 * a)
        }
    }

    fn ray_color(r: &Ray) -> Color {
        let t = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r);
        if t > 0.0 {
            let n = vec3::unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
            return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
        }

        let unit_direction = vec3::unit_vector(r.direction());
        let t = 0.5 * (unit_direction.y() + 1.0);
        (1.0 - t) * Color::new(1.0, 1.0, 1.0) + t * Color::new(0.5, 0.7, 1.0)
    }

    fn main() {
        // Image

        const ASPECT_RATIO: f64 = 16.0 / 9.0;
        const IMAGE_WIDTH: i32 = 400;
        const IMAGE_HEIGHT: i32 = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;

        // Camera

        let viewport_height = 2.0;
        let viewport_width = ASPECT_RATIO * viewport_height;
        let focal_length = 1.0;

        let origin = Point3::new(0.0, 0.0, 0.0);
        let horizontal = Vec3::new(viewport_width, 0.0, 0.0);
        let vertical = Vec3::new(0.0, viewport_height, 0.0);
        let lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3::new(0.0, 0.0, focal_length);

        // Render

        print!("P3\n{} {}\n255\n", IMAGE_WIDTH, IMAGE_HEIGHT);

        for j in (0..IMAGE_HEIGHT).rev() {
            eprint!("\rScanlines remaining: {} ", j);
            for i in 0..IMAGE_WIDTH {
                let u = i as f64 / (IMAGE_WIDTH - 1) as f64;
                let v = j as f64 / (IMAGE_HEIGHT - 1) as f64;
                let r = Ray::new(
                    origin,
                    lower_left_corner + u * horizontal + v * vertical - origin,
                );
                let pixel_color = ray_color(&r);
                color::write_color(&mut io::stdout(), pixel_color);
            }
        }

        eprint!("\nDone.\n");
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="main.cpp | Rendering surface normals on a sphere" {7,13-17,21-24,28} genImage
    #include <iostream>

    #include "color.h"
    #include "ray.h"
    #include "vec3.h"

    double hit_sphere(Point3 center, double radius, const Ray &r) {
        Vec3 oc = r.origin() - center;
        auto a = dot(r.direction(), r.direction());
        auto b = 2.0 * dot(oc, r.direction());
        auto c = dot(oc, oc) - radius * radius;
        auto discriminant = b * b - 4.0 * a * c;
        if (discriminant < 0.0) {
            return -1.0;
        } else {
            return (-b - sqrt(discriminant)) / (2.0 * a);
        }
    }

    Color ray_color(const Ray &r) {
        auto t = hit_sphere(Point3(0.0, 0.0, -1.0), 0.5, r);
        if (t > 0.0) {
            Vec3 n = unit_vector(r.at(t) - Vec3(0.0, 0.0, -1.0));
            return 0.5 * Color(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
        }

        Vec3 unit_direction = unit_vector(r.direction());
        t = 0.5 * (unit_direction.y() + 1.0);
        return (1.0 - t) * Color(1.0, 1.0, 1.0) + t * Color(0.5, 0.7, 1.0);
    }

    int main() {
        // Image

        const double ASPECT_RATIO = 16.0 / 9.0;
        const int IMAGE_WIDTH = 400;
        const int IMAGE_HEIGHT = static_cast<int>(IMAGE_WIDTH / ASPECT_RATIO);

        // Camera

        auto viewport_height = 2.0;
        auto viewport_width = ASPECT_RATIO * viewport_height;
        auto focal_length = 1.0;

        auto origin = Point3(0.0, 0.0, 0.0);
        auto horizontal = Vec3(viewport_width, 0.0, 0.0);
        auto vertical = Vec3(0.0, viewport_height, 0.0);
        auto lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3(0.0, 0.0, focal_length);

        // Render

        std::cout << "P3\n" << IMAGE_WIDTH << ' ' << IMAGE_HEIGHT << "\n255\n";

        for (int j = IMAGE_HEIGHT - 1; j >= 0; --j) {
            std::cerr << "\rScanlines remaining: " << j << ' ';
            for (int i = 0; i < IMAGE_WIDTH; ++i) {
                auto u = static_cast<double>(i) / (IMAGE_WIDTH - 1);
                auto v = static_cast<double>(j) / (IMAGE_HEIGHT - 1);
                Ray r(origin, lower_left_corner + u * horizontal + v * vertical - origin);
                Color pixel_color = ray_color(r);
                write_color(std::cout, pixel_color);
            }
        }

        std::cerr << "\nDone.\n";

        return 0;
    }
    ```
  </Tab>
</Tabs>

And that yields this picture:

![Image 4: A sphere colored according to its normal vectors](../images/img-1.04-normals-sphere.png)

## Simplifying the Ray-Sphere Intersection Code

Let's revisit the ray-sphere equation:

```cpp filename="Ray-sphere intersection code (before)"
double hit_sphere(const point3& center, double radius, const ray& r) {
    vec3 oc = r.origin() - center;
    auto a = dot(r.direction(), r.direction());
    auto b = 2.0 * dot(oc, r.direction());
    auto c = dot(oc, oc) - radius*radius;
    auto discriminant = b*b - 4*a*c;
    if (discriminant < 0) {
        return -1.0;
    } else {
        return (-b - sqrt(discriminant) ) / (2.0*a);
    }
}
```

First, recall that a vector dotted with itself is equal to the squared length of that vector.

Second, notice how the equation for `b` has a factor of two in it. Consider what happens to the
quadratic equation if $b = 2h$:

$$
\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
$$

$$
= \frac{-2h \pm \sqrt{(2h)^2 - 4ac}}{2a}
$$

$$
= \frac{-2h \pm 2\sqrt{h^2 - ac}}{2a}
$$

$$
= \frac{-h \pm \sqrt{h^2 - ac}}{a}
$$

Using these observations, we can now simplify the sphere-intersection code to this:

<Tabs>
  <Tab label="Rust">
    ```rust filename="main.rs | Ray-sphere intersection code (after)" {13-16,20}
    mod color;
    mod ray;
    mod vec3;

    use std::io;

    use color::Color;
    use ray::Ray;
    use vec3::{Point3, Vec3};

    fn hit_sphere(center: Point3, radius: f64, r: &Ray) -> f64 {
        let oc = r.origin() - center;
        let a = r.direction().length_squared();
        let half_b = vec3::dot(oc, r.direction());
        let c = oc.length_squared() - radius * radius;
        let discriminant = half_b * half_b - a * c;
        if discriminant < 0.0 {
            -1.0
        } else {
            (-half_b - f64::sqrt(discriminant)) / a
        }
    }

    fn ray_color(r: &Ray) -> Color {
        let t = hit_sphere(Point3::new(0.0, 0.0, -1.0), 0.5, r);
        if t > 0.0 {
            let n = vec3::unit_vector(r.at(t) - Vec3::new(0.0, 0.0, -1.0));
            return 0.5 * Color::new(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
        }

        let unit_direction = vec3::unit_vector(r.direction());
        let t = 0.5 * (unit_direction.y() + 1.0);
        (1.0 - t) * Color::new(1.0, 1.0, 1.0) + t * Color::new(0.5, 0.7, 1.0)
    }

    fn main() {
        // Image

        const ASPECT_RATIO: f64 = 16.0 / 9.0;
        const IMAGE_WIDTH: i32 = 400;
        const IMAGE_HEIGHT: i32 = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;

        // Camera

        let viewport_height = 2.0;
        let viewport_width = ASPECT_RATIO * viewport_height;
        let focal_length = 1.0;

        let origin = Point3::new(0.0, 0.0, 0.0);
        let horizontal = Vec3::new(viewport_width, 0.0, 0.0);
        let vertical = Vec3::new(0.0, viewport_height, 0.0);
        let lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3::new(0.0, 0.0, focal_length);

        // Render

        print!("P3\n{} {}\n255\n", IMAGE_WIDTH, IMAGE_HEIGHT);

        for j in (0..IMAGE_HEIGHT).rev() {
            eprint!("\rScanlines remaining: {} ", j);
            for i in 0..IMAGE_WIDTH {
                let u = i as f64 / (IMAGE_WIDTH - 1) as f64;
                let v = j as f64 / (IMAGE_HEIGHT - 1) as f64;
                let r = Ray::new(
                    origin,
                    lower_left_corner + u * horizontal + v * vertical - origin,
                );
                let pixel_color = ray_color(&r);
                color::write_color(&mut io::stdout(), pixel_color);
            }
        }

        eprint!("\nDone.\n");
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="main.cpp | Ray-sphere intersection code (after)" {9-12,16}
    #include <iostream>

    #include "color.h"
    #include "ray.h"
    #include "vec3.h"

    double hit_sphere(Point3 center, double radius, const Ray &r) {
        Vec3 oc = r.origin() - center;
        auto a = r.direction().length_squared();
        auto half_b = dot(oc, r.direction());
        auto c = oc.length_squared() - radius * radius;
        auto discriminant = half_b * half_b - a * c;
        if (discriminant < 0.0) {
            return -1.0;
        } else {
            return (-half_b - sqrt(discriminant)) / a;
        }
    }

    Color ray_color(const Ray &r) {
        auto t = hit_sphere(Point3(0.0, 0.0, -1.0), 0.5, r);
        if (t > 0.0) {
            Vec3 n = unit_vector(r.at(t) - Vec3(0.0, 0.0, -1.0));
            return 0.5 * Color(n.x() + 1.0, n.y() + 1.0, n.z() + 1.0);
        }

        Vec3 unit_direction = unit_vector(r.direction());
        t = 0.5 * (unit_direction.y() + 1.0);
        return (1.0 - t) * Color(1.0, 1.0, 1.0) + t * Color(0.5, 0.7, 1.0);
    }

    int main() {
        // Image

        const double ASPECT_RATIO = 16.0 / 9.0;
        const int IMAGE_WIDTH = 400;
        const int IMAGE_HEIGHT = static_cast<int>(IMAGE_WIDTH / ASPECT_RATIO);

        // Camera

        auto viewport_height = 2.0;
        auto viewport_width = ASPECT_RATIO * viewport_height;
        auto focal_length = 1.0;

        auto origin = Point3(0.0, 0.0, 0.0);
        auto horizontal = Vec3(viewport_width, 0.0, 0.0);
        auto vertical = Vec3(0.0, viewport_height, 0.0);
        auto lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3(0.0, 0.0, focal_length);

        // Render

        std::cout << "P3\n" << IMAGE_WIDTH << ' ' << IMAGE_HEIGHT << "\n255\n";

        for (int j = IMAGE_HEIGHT - 1; j >= 0; --j) {
            std::cerr << "\rScanlines remaining: " << j << ' ';
            for (int i = 0; i < IMAGE_WIDTH; ++i) {
                auto u = static_cast<double>(i) / (IMAGE_WIDTH - 1);
                auto v = static_cast<double>(j) / (IMAGE_HEIGHT - 1);
                Ray r(origin, lower_left_corner + u * horizontal + v * vertical - origin);
                Color pixel_color = ray_color(r);
                write_color(std::cout, pixel_color);
            }
        }

        std::cerr << "\nDone.\n";

        return 0;
    }
    ```
  </Tab>
</Tabs>

## An Abstraction for Hittable Objects

Now, how about several spheres? While it is tempting to have an array of spheres, a very clean
solution is the make an "abstract class" for anything a ray might hit, and make both a sphere and a
list of spheres just something you can hit. What that class should be called is something of a
quandary -- calling it an "object" would be good if not for "object oriented" programming. "Surface"
is often used, with the weakness being maybe we will want volumes. "hittable" emphasizes the member
function that unites them. I don't love any of these, but I will go with "hittable".

This `hittable` abstract class will have a hit function that takes in a ray. Most ray tracers have
found it convenient to add a valid interval for hits $t_{min}$ to $t_{max}$, so the hit only
"counts" if $t_{min} < t < t_{max}$. For the initial rays this is positive $t$, but as we will see,
it can help some details in the code to have an interval $t_{min}$ to $t_{max}$. One design question
is whether to do things like compute the normal if we hit something. We might end up hitting
something closer as we do our search, and we will only need the normal of the closest thing. I will
go with the simple solution and compute a bundle of stuff I will store in some structure. Here's
the abstract class:

<Tabs>
  <Tab label="Rust">
    ```rust filename="hittable.rs | The Hittable trait" {1-19}
    use crate::ray::Ray;
    use crate::vec3::{self, Point3, Vec3};

    #[derive(Clone, Default)]
    pub struct HitRecord {
        pub p: Point3,
        pub normal: Vec3,
        pub t: f64,
    }

    impl HitRecord {
        pub fn new() -> HitRecord {
            Default::default()
        }
    }

    pub trait Hittable {
        fn hit(&self, ray: &Ray, t_min: f64, t_max: f64, rec: &mut HitRecord) -> bool;
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="hittable.h | The Hittable abstract class" {1-21}
    #ifndef HITTABLE_H
    #define HITTABLE_H

    #include "ray.h"

    struct HitRecord {
        HitRecord() = default;

        Point3 p;
        Vec3 normal;
        double t = 0.0;
    };

    class Hittable {
    public:
        virtual ~Hittable() = default;

        virtual bool hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const = 0;
    };

    #endif
    ```
  </Tab>
</Tabs>

And here's the sphere:

<Tabs>
  <Tab label="Rust">
    ```rust filename="sphere.rs | The Sphere struct" {1-47}
    use crate::hittable::{HitRecord, Hittable};
    use crate::ray::Ray;
    use crate::vec3::{self, Point3};

    pub struct Sphere {
        center: Point3,
        radius: f64,
    }

    impl Sphere {
        pub fn new(cen: Point3, r: f64) -> Sphere {
            Sphere {
                center: cen,
                radius: r,
            }
        }
    }

    impl Hittable for Sphere {
        fn hit(&self, r: &Ray, t_min: f64, t_max: f64, rec: &mut HitRecord) -> bool {
            let oc = r.origin() - self.center;
            let a = r.direction().length_squared();
            let half_b = vec3::dot(oc, r.direction());
            let c = oc.length_squared() - self.radius * self.radius;
            let discriminant = half_b * half_b - a * c;
            if discriminant < 0.0 {
                return false;
            }

            let sqrt_d = f64::sqrt(discriminant);

            // Find the nearest root that lies in the acceptable range
            let mut root = (-half_b - sqrt_d) / a;
            if root <= t_min || t_max <= root {
                root = (-half_b + sqrt_d) / a;
                if root <= t_min || t_max <= root {
                    return false;
                }
            }

            rec.t = root;
            rec.p = r.at(rec.t);
            rec.normal = (rec.p - center) / radius;

            true
        }
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="sphere.h | The Sphere class" {1-46}
    #ifndef SPHERE_H
    #define SPHERE_H

    #include "hittable.h"
    #include "vec3.h"

    class Sphere : public Hittable {
    public:
        Sphere(Point3 cen, double r) : center{cen}, radius{r} {};

        bool hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const override;

    private:
        Point3 center;
        double radius;
    };

    inline bool Sphere::hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const {
        Vec3 oc = r.origin() - center;
        auto a = r.direction().length_squared();
        auto half_b = dot(oc, r.direction());
        auto c = oc.length_squared() - radius * radius;
        auto discriminant = half_b * half_b - a * c;
        if (discriminant < 0.0) {
            return false;
        }

        auto sqrt_d = sqrt(discriminant);

        // Find the nearest root that lies in the acceptable range
        auto root = (-half_b - sqrt_d) / a;
        if (root <= t_min || t_max <= root) {
            root = (-half_b + sqrt_d) / a;
            if (root <= t_min || t_max <= root) {
                return false;
            }
        }

        rec.t = root;
        rec.p = r.at(rec.t);
        rec.normal = (rec.p - center) / radius;

        return true;
    }

    #endif
    ```
  </Tab>
</Tabs>

## Front Faces Versus Back Faces

The second design decision for normals is whether they should always point out. At present, the
normal found will always be in the direction of the center to the intersection point (the normal
points out). If the ray intersects the sphere from the outside, the normal points against the ray.
If the ray intersects the sphere from the inside, the normal (which always points out) points with
the ray. Alternatively, we can have the normal always point against the ray. If the ray is outside
the sphere, the normal will point outward, but if the ray is inside the sphere, the normal will
point inward.

![Figure \[normal-sides\]: Possible directions for sphere surface-normal geometry](../images/fig-1.06-normal-sides.jpg)

We need to choose one of these possibilities because we will eventually want to determine which
side of the surface that the ray is coming from. This is important for objects that are rendered
differently on each side, like the text on a two-sided sheet of paper, or for objects that have an
inside and an outside, like glass balls.

If we decide to have the normals always point out, then we will need to determine which side the
ray is on when we color it. We can figure this out by comparing the ray with the normal. If the ray
and the normal face in the same direction, the ray is inside the object, if the ray and the normal
face in the opposite direction, then the ray is outside the object. This can be determined by
taking the dot product of the two vectors, where if their dot is positive, the ray is inside the
sphere.

```cpp filename="Comparing the ray and the normal"
if (dot(ray_direction, outward_normal) > 0.0) {
    // ray is inside the sphere
    ...
} else {
    // ray is outside the sphere
    ...
}
```

If we decide to have the normals always point against the ray, we won't be able to use the dot
product to determine which side of the surface the ray is on. Instead, we would need to store that
information:

```cpp filename="Remembering the side of the surface"
bool front_face;
if (dot(ray_direction, outward_normal) > 0.0) {
    // ray is inside the sphere
    normal = -outward_normal;
    front_face = false;
} else {
    // ray is outside the sphere
    normal = outward_normal;
    front_face = true;
}
```

We can set things up so that normals always point "outward" from the surface, or always point
against the incident ray. This decision is determined by whether you want to determine the side of
the surface at the time of geometry intersection or at the time of coloring. In this book we have
more material types than we have geometry types, so we'll go for less work and put the determination
at geometry time. This is simply a matter of preference, and you'll see both implementations in the
literature.

We add the `front_face` bool to the `hit_record` struct. We'll also add a function to solve this
calculation for us.

<Tabs>
  <Tab label="Rust">
    ```rust filename="hittable.rs | Adding front-face tracking to HitRecord" {9,16-24}
    use crate::ray::Ray;
    use crate::vec3::{self, Point3, Vec3};

    #[derive(Clone, Default)]
    pub struct HitRecord {
        pub p: Point3,
        pub normal: Vec3,
        pub t: f64,
        pub front_face: bool,
    }

    impl HitRecord {
        pub fn new() -> HitRecord {
            Default::default()
        }

        pub fn set_face_normal(&mut self, r: &Ray, outward_normal: Vec3) {
            self.front_face = vec3::dot(r.direction(), outward_normal) < 0.0;
            self.normal = if self.front_face {
                outward_normal
            } else {
                -outward_normal
            };
        }
    }

    pub trait Hittable {
        fn hit(&self, ray: &Ray, t_min: f64, t_max: f64, rec: &mut HitRecord) -> bool;
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="hittable.h | Adding front-face tracking to HitRecord" {5,9-13,18}
    #ifndef HITTABLE_H
    #define HITTABLE_H

    #include "ray.h"
    #include "vec3.h"

    struct HitRecord {
        HitRecord() = default;

        void set_face_normal(const Ray &r, Vec3 outward_normal) {
            front_face = dot(r.direction(), outward_normal) < 0.0;
            normal = front_face ? outward_normal : -outward_normal;
        }

        Point3 p;
        Vec3 normal;
        double t = 0.0;
        bool front_face = false;
    };

    class Hittable {
    public:
        virtual ~Hittable() = default;

        virtual bool hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const = 0;
    };

    #endif
    ```
  </Tab>
</Tabs>

And then we add the surface side determination to the class:

<Tabs>
  <Tab label="Rust">
    ```rust filename="sphere.rs | The Sphere struct with normal determination" {43-44}
    use crate::hittable::{HitRecord, Hittable};
    use crate::ray::Ray;
    use crate::vec3::{self, Point3};

    pub struct Sphere {
        center: Point3,
        radius: f64,
    }

    impl Sphere {
        pub fn new(cen: Point3, r: f64) -> Sphere {
            Sphere {
                center: cen,
                radius: r,
            }
        }
    }

    impl Hittable for Sphere {
        fn hit(&self, r: &Ray, t_min: f64, t_max: f64, rec: &mut HitRecord) -> bool {
            let oc = r.origin() - self.center;
            let a = r.direction().length_squared();
            let half_b = vec3::dot(oc, r.direction());
            let c = oc.length_squared() - self.radius * self.radius;
            let discriminant = half_b * half_b - a * c;
            if discriminant < 0.0 {
                return false;
            }

            let sqrt_d = f64::sqrt(discriminant);

            // Find the nearest root that lies in the acceptable range
            let mut root = (-half_b - sqrt_d) / a;
            if root <= t_min || t_max <= root {
                root = (-half_b + sqrt_d) / a;
                if root <= t_min || t_max <= root {
                    return false;
                }
            }

            rec.t = root;
            rec.p = r.at(rec.t);
            let outward_normal = (rec.p - self.center) / self.radius;
            rec.set_face_normal(r, outward_normal);

            true
        }
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="sphere.h | The Sphere class with normal determination" {41-42}
    #ifndef SPHERE_H
    #define SPHERE_H

    #include "hittable.h"
    #include "vec3.h"

    class Sphere : public Hittable {
    public:
        Sphere(Point3 cen, double r) : center{cen}, radius{r} {};

        bool hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const override;

    private:
        Point3 center;
        double radius;
    };

    inline bool Sphere::hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const {
        Vec3 oc = r.origin() - center;
        auto a = r.direction().length_squared();
        auto half_b = dot(oc, r.direction());
        auto c = oc.length_squared() - radius * radius;
        auto discriminant = half_b * half_b - a * c;
        if (discriminant < 0.0) {
            return false;
        }

        auto sqrt_d = sqrt(discriminant);

        // Find the nearest root that lies in the acceptable range
        auto root = (-half_b - sqrt_d) / a;
        if (root <= t_min || t_max <= root) {
            root = (-half_b + sqrt_d) / a;
            if (root <= t_min || t_max <= root) {
                return false;
            }
        }

        rec.t = root;
        rec.p = r.at(rec.t);
        Vec3 outward_normal = (rec.p - center) / radius;
        rec.set_face_normal(r, outward_normal);

        return true;
    }

    #endif
    ```
  </Tab>
</Tabs>

## A List of Hittable Objects

We have a generic object called a `hittable` that the ray can intersect with. We now add a class
that stores a list of `hittable`s:

<Tabs>
  <Tab label="Rust">
    ```rust filename="hittable_list.rs | The HittableList struct" {1-35}
    use crate::hittable::{HitRecord, Hittable};
    use crate::ray::Ray;

    #[derive(Default)]
    pub struct HittableList {
        objects: Vec<Box<dyn Hittable>>,
    }

    impl HittableList {
        pub fn new() -> HittableList {
            Default::default()
        }

        pub fn add(&mut self, object: Box<dyn Hittable>) {
            self.objects.push(object);
        }
    }

    impl Hittable for HittableList {
        fn hit(&self, ray: &Ray, t_min: f64, t_max: f64, rec: &mut HitRecord) -> bool {
            let mut temp_rec = HitRecord::new();
            let mut hit_anything = false;
            let mut closest_so_far = t_max;

            for object in &self.objects {
                if object.hit(ray, t_min, closest_so_far, &mut temp_rec) {
                    hit_anything = true;
                    closest_so_far = temp_rec.t;
                    *rec = temp_rec.clone();
                }
            }

            hit_anything
        }
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="hittable_list.h | The HittableList class" {1-39}
    #ifndef HITTABLE_LIST_H
    #define HITTABLE_LIST_H

    #include <memory>
    #include <vector>

    #include "hittable.h"

    class HittableList : public Hittable {
    public:
        HittableList() = default;

        void add(std::unique_ptr<Hittable> object) {
            objects.push_back(std::move(object));
        }

        bool hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const override;

    private:
        std::vector<std::unique_ptr<Hittable>> objects;
    };

    inline bool HittableList::hit(const Ray &r, double t_min, double t_max, HitRecord &rec) const {
        HitRecord temp_rec;
        auto hit_anything = false;
        auto closet_so_far = t_max;

        for (const auto &object : objects) {
            if (object->hit(r, t_min, closet_so_far, temp_rec)) {
                hit_anything = true;
                closet_so_far = temp_rec.t;
                rec = temp_rec;
            }
        }

        return hit_anything;
    }

    #endif
    ```
  </Tab>
</Tabs>

## Some New C++ Features

The `hittable_list` class code uses two C++ features that may trip you up if you're not normally a
C++ programmer: `vector` and `shared_ptr`.

`shared_ptr<type>` is a pointer to some allocated type, with reference-counting semantics.
Every time you assign its value to another shared pointer (usually with a simple assignment), the
reference count is incremented. As shared pointers go out of scope (like at the end of a block or
function), the reference count is decremented. Once the count goes to zero, the object is deleted.

Typically, a shared pointer is first initialized with a newly-allocated object, something like this:

```cpp filename="An example allocation using shared_ptr"
shared_ptr<double> double_ptr = make_shared<double>(0.37);
shared_ptr<vec3>   vec3_ptr   = make_shared<vec3>(1.414214, 2.718281, 1.618034);
shared_ptr<sphere> sphere_ptr = make_shared<sphere>(point3(0,0,0), 1.0);
```

`make_shared<thing>(thing_constructor_params ...)` allocates a new instance of type `thing`, using
the constructor parameters. It returns a `shared_ptr<thing>`.

Since the type can be automatically deduced by the return type of `make_shared<type>(...)`, the
above lines can be more simply expressed using C++'s `auto` type specifier:

```cpp filename="An example allocation using shared_ptr with auto type"
auto double_ptr = make_shared<double>(0.37);
auto vec3_ptr   = make_shared<vec3>(1.414214, 2.718281, 1.618034);
auto sphere_ptr = make_shared<sphere>(point3(0,0,0), 1.0);
```

We'll use shared pointers in our code, because it allows multiple geometries to share a common
instance (for example, a bunch of spheres that all use the same texture map material), and because
it makes memory management automatic and easier to reason about.

`std::shared_ptr` is included with the `<memory>` header.

The second C++ feature you may be unfamiliar with is `std::vector`. This is a generic array-like
collection of an arbitrary type. Above, we use a collection of pointers to `hittable`. `std::vector`
automatically grows as more values are added: `objects.push_back(object)` adds a value to the end of
the `std::vector` member variable `objects`.

`std::vector` is included with the `<vector>` header.

Finally, the `using` statements in listing \[hittable-list-initial] tell the compiler that we'll be
getting `shared_ptr` and `make_shared` from the `std` library, so we don't need to prefex these with
`std::` every time we reference them.

## Common Constants and Utility Functions

We need some math constants that we conveniently define in their own header file. For now we only
need infinity, but we will also throw our own definition of pi in there, which we will need later.
There is no standard portable definition of pi, so we just define our own constant for it. We'll
throw common useful constants and future utility functions in `rtweekend.h`, our general main header
file.

<Tabs>
  <Tab label="Rust">
    ```rust filename="common.rs | The common module" {1-10}
    // Constants

    pub use std::f64::consts::PI;
    pub use std::f64::INFINITY;

    // Utility functions

    pub fn degrees_to_radians(degrees: f64) -> f64 {
        degrees * PI / 180.0
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="common.h | The common header" {1-18}
    #ifndef COMMON_H
    #define COMMON_H

    #include <limits>

    // Constants

    #undef INFINITY // Undefine the C macro in the cmath header
    inline const double INFINITY = std::numeric_limits<double>::infinity();
    inline const double PI = 3.1415926535897932385;

    // Utility functions

    inline double degrees_to_radians(double degrees) {
        return degrees * PI / 180.0;
    }

    #endif
    ```
  </Tab>
</Tabs>

And the new main:

<Tabs>
  <Tab label="Rust">
    ```rust filename="main.rs | The new main with Hittables" {2-4,6,12-13,15,18-21,35-40,67} genImage
    mod color;
    mod common;
    mod hittable;
    mod hittable_list;
    mod ray;
    mod sphere;
    mod vec3;

    use std::io;

    use color::Color;
    use hittable::{HitRecord, Hittable};
    use hittable_list::HittableList;
    use ray::Ray;
    use sphere::Sphere;
    use vec3::{Point3, Vec3};

    fn ray_color(r: &Ray, world: &dyn Hittable) -> Color {
        let mut rec = HitRecord::new();
        if world.hit(r, 0.0, common::INFINITY, &mut rec) {
            return 0.5 * (rec.normal + Color::new(1.0, 1.0, 1.0));
        }

        let unit_direction = vec3::unit_vector(r.direction());
        let t = 0.5 * (unit_direction.y() + 1.0);
        (1.0 - t) * Color::new(1.0, 1.0, 1.0) + t * Color::new(0.5, 0.7, 1.0)
    }

    fn main() {
        // Image

        const ASPECT_RATIO: f64 = 16.0 / 9.0;
        const IMAGE_WIDTH: i32 = 400;
        const IMAGE_HEIGHT: i32 = (IMAGE_WIDTH as f64 / ASPECT_RATIO) as i32;

        // World

        let mut world = HittableList::new();
        world.add(Box::new(Sphere::new(Point3::new(0.0, 0.0, -1.0), 0.5)));
        world.add(Box::new(Sphere::new(Point3::new(0.0, -100.5, -1.0), 100.0)));

        // Camera

        let viewport_height = 2.0;
        let viewport_width = ASPECT_RATIO * viewport_height;
        let focal_length = 1.0;

        let origin = Point3::new(0.0, 0.0, 0.0);
        let horizontal = Vec3::new(viewport_width, 0.0, 0.0);
        let vertical = Vec3::new(0.0, viewport_height, 0.0);
        let lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3::new(0.0, 0.0, focal_length);

        // Render

        print!("P3\n{} {}\n255\n", IMAGE_WIDTH, IMAGE_HEIGHT);

        for j in (0..IMAGE_HEIGHT).rev() {
            eprint!("\rScanlines remaining: {} ", j);
            for i in 0..IMAGE_WIDTH {
                let u = i as f64 / (IMAGE_WIDTH - 1) as f64;
                let v = j as f64 / (IMAGE_HEIGHT - 1) as f64;
                let r = Ray::new(
                    origin,
                    lower_left_corner + u * horizontal + v * vertical - origin,
                );
                let pixel_color = ray_color(&r, &world);
                color::write_color(&mut io::stdout(), pixel_color);
            }
        }

        eprint!("\nDone.\n");
    }
    ```
  </Tab>

  <Tab label="C++">
    ```cpp filename="main.cpp | The new main with Hittables" {4-6,8,11-14,18,28-33,57} genImage
    #include <iostream>

    #include "color.h"
    #include "common.h"
    #include "hittable.h"
    #include "hittable_list.h"
    #include "ray.h"
    #include "sphere.h"
    #include "vec3.h"

    Color ray_color(const Ray &r, const Hittable &world) {
        HitRecord rec;
        if (world.hit(r, 0.0, INFINITY, rec)) {
            return 0.5 * (rec.normal + Color(1.0, 1.0, 1.0));
        }

        Vec3 unit_direction = unit_vector(r.direction());
        auto t = 0.5 * (unit_direction.y() + 1.0);
        return (1.0 - t) * Color(1.0, 1.0, 1.0) + t * Color(0.5, 0.7, 1.0);
    }

    int main() {
        // Image

        const double ASPECT_RATIO = 16.0 / 9.0;
        const int IMAGE_WIDTH = 400;
        const int IMAGE_HEIGHT = static_cast<int>(IMAGE_WIDTH / ASPECT_RATIO);

        // World

        HittableList world;
        world.add(std::make_unique<Sphere>(Point3(0.0, 0.0, -1.0), 0.5));
        world.add(std::make_unique<Sphere>(Point3(0.0, -100.5, -1.0), 100.0));

        // Camera

        auto viewport_height = 2.0;
        auto viewport_width = ASPECT_RATIO * viewport_height;
        auto focal_length = 1.0;

        auto origin = Point3(0.0, 0.0, 0.0);
        auto horizontal = Vec3(viewport_width, 0.0, 0.0);
        auto vertical = Vec3(0.0, viewport_height, 0.0);
        auto lower_left_corner =
            origin - horizontal / 2.0 - vertical / 2.0 - Vec3(0.0, 0.0, focal_length);

        // Render

        std::cout << "P3\n" << IMAGE_WIDTH << ' ' << IMAGE_HEIGHT << "\n255\n";

        for (int j = IMAGE_HEIGHT - 1; j >= 0; --j) {
            std::cerr << "\rScanlines remaining: " << j << ' ';
            for (int i = 0; i < IMAGE_WIDTH; ++i) {
                auto u = static_cast<double>(i) / (IMAGE_WIDTH - 1);
                auto v = static_cast<double>(j) / (IMAGE_HEIGHT - 1);
                Ray r(origin, lower_left_corner + u * horizontal + v * vertical - origin);
                Color pixel_color = ray_color(r, world);
                write_color(std::cout, pixel_color);
            }
        }

        std::cerr << "\nDone.\n";

        return 0;
    }
    ```
  </Tab>
</Tabs>

This yields a picture that is really just a visualization of where the spheres are along with their
surface normal. This is often a great way to look at your model for flaws and characteristics.

![Image 5: Resulting render of normals-colored sphere with ground](../images/img-1.05-normals-sphere-ground.png)
